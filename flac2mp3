#!/usr/bin/env python3

import os, sys
import argparse
import subprocess
import shutil
from multiprocessing.pool import ThreadPool
import re


"""Transcode FLAC audio to mp3, with user-configurable quality and intelligent
directory handling.  Metadata will be preserved at both the audio and filesystem
levels."""

# Binary names we might expect to find ffmpeg/avconv with
AVCONV_NAMES = ('avconv', 'ffmpeg')


# These are meaningless after transcoding; don't copy them
NO_COPY_EXTS = ('.log', '.cue', 'm3u')


# Default LAME quality setting - 0 is best, 9 is worst.  0-3 are considered 
# transparent.
DEFAULT_VBR_QUAL = 2   # Use 0-1 for particularly complex music




def autodetect_avconv(force=None):
    """Search $PATH to find an avconv/ffmpeg binary
    
    Args:
        None
    
    Raises:
        IOError - Couldn't find any executable avconv/ffmpeg
    
    Returns:
        string location of binary
    """
    def _match(f):
        return os.path.isfile(f) and os.access(f, os.X_OK)
    def _find(paths, matchFunc=os.path.isfile):
        for dirname in os.getenv('PATH', '').split(':'):
            for p in paths:
                candidate = os.path.join(dirname, p)
                # print("Testing {}".format(candidate))
                if matchFunc(candidate):
                    return candidate
        raise IOError("Can't find executables for {}".format('/'.join(paths)))
    if force is not None:
        if not _match(force):
            raise IOError("Forced avconv binary {} is missing/noexec".format(force))
        return force
    else:
        return _find(AVCONV_NAMES, _match)



def subp_transcode(f_source, f_dest, avconv='/usr/local/bin/ffmpeg', lame_vbr_quality=3):
    """Use avconv/ffmpeg to transcode a flac file into an mp3 with the supplied
    quality settings.
    
    Args:
        f_source:         source file, which must be flac
        f_dest:           dest file, which must be mp3
        avconv:           path to avconv/ffmpeg binary
        lame_vbr_quality: VBR setting passed to encoder.  0 is best.
    
    Raises:
        TypeError:  f_source or f_dest wasn't a string
        ValueError: supplied sources were of the wrong file type
        IOError:    dest path is not a directory / couldn't be created
        
    Returns:
        Tuple of (f_source, success, output)
    """
    # print("In subp_transcode()")
    # print("  SRC '{}'".format(f_source))
    # print("  DST '{}'".format(f_dest))
    if not isinstance(f_source, str):
        raise TypeError("f_source must be a str")
    if not isinstance(f_dest, str):
        raise TypeError("f_dest must be a str")
    if not f_source.lower().endswith('.flac'):
        raise ValueError("Can only transcode from flac files, not '{}'".format(f_source))
    if not f_dest.lower().endswith('.mp3'):
        raise ValueError("Can only transcode to mp3 files, not '{}'".format(f_dest))
    p_args = [
        avconv,
        '-y',
        '-i', f_source,
        '-loglevel', 'error',
        '-c:v', 'copy',
        '-codec:a', 'libmp3lame',
        '-q:a', str(lame_vbr_quality),
        '-map_metadata', '0',
        '-id3v2_version', '3',
         '-write_id3v1', '1',
        f_dest
    ]
    # print("'{}' => '{}'".format(f_source, f_dest))
    # Rewrite this to use subprocess.run() once Python 3.5 is more common
    try:
        output = subprocess.check_output(
            p_args,
            stdin=subprocess.DEVNULL,
            stderr=subprocess.STDOUT
        )
    except CalledProcessError as e:
        return (f_source, False, e.output)
    finally:
        if os.path.isfile(f_dest):
            shutil.copystat(f_source, f_dest)
    return (f_source, True, output)


# Use this for finding/replacing flac in dir names
RE_FLAC = re.compile(r'\Wflac\W', re.IGNORECASE)

def destdir_name(d_source):
    """Generate a destination directory name for the converted album, with
    'mp3' somewhere in it.
    
    Args:
        d_source: string directory name
    
    Returns:
        string to use for a new directory name
    """
    source_dir_dir  = os.path.dirname(d_source)
    source_dir_name = os.path.basename(d_source)
    if RE_FLAC.search(source_dir_name):
        new_dir_name = RE_FLAC.sub('[mp3]', source_dir_name)
    else:
        new_dir_name = "{} [mp3]".format(source_dir_name)
    return os.path.join(source_dir_dir, new_dir_name)


    
def jobs(source, clobber=False):
    """Yield a stream of jobs to do for a given file/album.  Create dest
    dir if necessary.
    
    Args:
        source: 
    
    Raises:
        IOError: source is not a directory or flac file
    
    Yields:
        Tuples of (type, f_source, f_dest) where 'type' is one of 't' for
        transcode or 'c' for copy, f_source is the path to be copied and f_dest
        is where it ends up.
    """
    if os.path.isfile(source) and source.lower().endswith('.flac'):
        yield (     't',
                    source,
                    re.sub(r'\.flac$', '.mp3', source, re.IGNORECASE)
        )
    elif os.path.isdir(source):
        source = source.rstrip('/') # otherwise we get a weird [mp3] dir within
        d_dest = destdir_name(source)
        if os.path.exists(d_dest):
            if clobber:
                print("Dest dir '{}' already exists; deleting".format(d_dest))
                shutil.rmtree(d_dest)
            else:
                raise IOError("Dest dir '{}' already exists; won't clobber".format(d_dest))
        os.makedirs(d_dest, exist_ok=True)
        shutil.copystat(source, d_dest)
        for path in os.listdir(source):
            f_source = os.path.join(source, path)
            if path.startswith('.'):
                continue
            elif path.lower().endswith(NO_COPY_EXTS):
                continue
            elif os.path.isfile(f_source) and path.lower().endswith('.flac'):
                yield (     't',
                            f_source,
                            os.path.join(
                                d_dest,
                                re.sub(r'\.flac$', '.mp3', path, re.IGNORECASE)
                            )
                )
            else:
                yield (     'c', 
                            f_source,
                            os.path.join(d_dest, path)
                )
    else:
        raise IOError("Target '{}' was neither a flac file nor directory")


    
    
parser = argparse.ArgumentParser(
    description="""Transcode flac files into mp3s while preserving tags, filesystem metadata and non-audio files.  Sources can be either individual flac files or directories containing then, which are recreated with a new name and mp3-ed contents.""",
    epilog="""Quality notes: default is VBR 2 - transparent for most music.  For electronic music you can get away with lower settings (e.g. 3-4) which discard more high-frequency data.\nSee http://wiki.hydrogenaud.io/index.php?title=LAME#Maximum_quality_and_archiving for more information."""
)

parser.add_argument('sources', metavar='SOURCE', type=str, nargs='+',
                    help='flac files or album dirs to transcode')
parser.add_argument('--delete', '-d', action='store_const', 
                    const=True, default=False,
                    help="delete any existing destination dirs")
parser.add_argument('--avconv', '-a', type=str,
                    help='force avconv/ffmpeg binary')
parser.add_argument('--quality', '-q', type=int, action='store',
                    default=DEFAULT_VBR_QUAL,
                    help='LAME VBR quality setting - 0 is best')
                    

if __name__ == '__main__':
    args = parser.parse_args()
    avconv = autodetect_avconv(args.avconv)
    print("Using avconv {}".format(avconv))
    def _cb(r):
        f_source, success, output = r
        print('='*78)
        if success:
            print("COMPLETED: {}".format(f_source))
        else:
            print("FAILED: {}".format(f_source))
        if len(output) > 0:
            print("OUTPUT:\n{}".format(str(output)))
        print('='*78)
        print()
    def _ecb(e):
        raise e
    with ThreadPool() as pool:
        for s in args.sources:
            for job in jobs(s, clobber=args.delete):
                job_type, f_source, f_dest = job
                if job_type == 't':
                    # print("ASYNC {}".format(str(job)))
                    pool.apply_async(
                        subp_transcode, 
                        (f_source, f_dest),
                        dict(avconv=avconv, lame_vbr_quality=args.quality),
                        _cb, _ecb
                    )
                elif job_type == 'c':
                    # print("SYNC  {}".format(str(job)))
                    print("'{}' -> '{}'".format(f_source, f_dest))
                    if os.path.isdir(f_source):
                        shutil.copytree(f_source, f_dest)
                    else:
                        shutil.copy2(f_source, f_dest)
                else:
                    raise RuntimeError("Unknown job type '{}'".format(job_type))
        print()
        pool.close()
        pool.join()



